"""
Cliente web para la API de optimizaci√≥n de portafolios
"""
import streamlit as st
import requests
import pandas as pd
import plotly.graph_objects as go
import plotly.express as px
from datetime import datetime, date
import json
import time

# Configuraci√≥n de la p√°gina
st.set_page_config(
    page_title="Portfolio Optimizer", 
    page_icon="üìà",
    layout="wide"
)

# Variables de configuraci√≥n
try:
    API_BASE_URL = st.secrets.get("API_URL", "http://localhost:8000")
except Exception:
    # Si no hay archivo de secretos, usar valor por defecto
    API_BASE_URL = "http://localhost:8000"

def make_api_request(endpoint: str, method: str = "GET", data: dict = None):
    """Realizar petici√≥n a la API"""
    url = f"{API_BASE_URL}{endpoint}"
    
    try:
        if method == "GET":
            response = requests.get(url, timeout=300)
        elif method == "POST":
            response = requests.post(url, json=data, timeout=300)
        elif method == "DELETE":
            response = requests.delete(url, timeout=300)
        
        response.raise_for_status()
        return response.json()
    
    except requests.exceptions.Timeout:
        st.error("‚è±Ô∏è Timeout: La petici√≥n tard√≥ demasiado tiempo")
        return None
    except requests.exceptions.ConnectionError:
        st.error(f"üîå Error de conexi√≥n: No se puede conectar a {API_BASE_URL}")
        return None
    except requests.exceptions.HTTPError as e:
        st.error(f"‚ùå Error HTTP {e.response.status_code}: {e.response.text}")
        return None
    except Exception as e:
        st.error(f"üö´ Error inesperado: {str(e)}")
        return None

def plot_performance_comparison(data):
    """Graficar comparaci√≥n de performance"""
    dates = pd.to_datetime(data['dates'])
    portfolio_returns = data['portfolio_cumulative_returns']
    benchmark_returns = data['benchmark_cumulative_returns']
    
    fig = go.Figure()
    
    # L√≠nea del portafolio
    fig.add_trace(go.Scatter(
        x=dates,
        y=[r * 100 for r in portfolio_returns],
        mode='lines',
        name='Portafolio (Sentiment Strategy)',
        line=dict(color='#1f77b4', width=3)
    ))
    
    # L√≠nea del benchmark
    fig.add_trace(go.Scatter(
        x=dates,
        y=[r * 100 for r in benchmark_returns],
        mode='lines',
        name='Benchmark (QQQ)',
        line=dict(color='#ff7f0e', width=2)
    ))
    
    fig.update_layout(
        title="Comparaci√≥n de Performance: Portafolio vs Benchmark",
        xaxis_title="Fecha",
        yaxis_title="Retorno Acumulativo (%)",
        hovermode='x unified',
        template="plotly_white",
        height=500
    )
    
    return fig

def show_portfolio_composition(composition_data):
    """Mostrar composici√≥n del portafolio"""
    if not composition_data:
        st.warning("No hay datos de composici√≥n disponibles")
        return
    
    # Crear DataFrame para an√°lisis
    comp_list = []
    for date, stocks in composition_data.items():
        for stock in stocks:
            comp_list.append({"Fecha": date, "Stock": stock})
    
    if comp_list:
        comp_df = pd.DataFrame(comp_list)
        
        # Contar frecuencia de stocks
        stock_counts = comp_df['Stock'].value_counts()
        
        col1, col2 = st.columns(2)
        
        with col1:
            st.subheader("üèÜ Stocks m√°s frecuentes")
            for i, (stock, count) in enumerate(stock_counts.head(10).items()):
                st.write(f"{i+1}. **{stock}**: {count} meses")
        
        with col2:
            st.subheader("üìÖ Composici√≥n por fecha")
            for date in sorted(composition_data.keys())[-5:]:  # √öltimas 5 fechas
                stocks = composition_data[date]
                st.write(f"**{date}**: {', '.join(stocks[:3])}{'...' if len(stocks) > 3 else ''}")

def main():
    """Funci√≥n principal de la aplicaci√≥n"""
    st.title("üìà Portfolio Optimization Dashboard")
    st.markdown("### ‚ö° An√°lisis de portafolio con **Ray** para paralelizaci√≥n")
    st.markdown("---")
    
    # Sidebar para configuraci√≥n
    st.sidebar.header("‚öôÔ∏è Configuraci√≥n")
    
    # Verificar estado de la API
    with st.sidebar:
        st.subheader("üîß Estado del Sistema")
        if st.button("Verificar Estado API"):
            with st.spinner("Verificando..."):
                health_data = make_api_request("/health")
                if health_data:
                    st.success("‚úÖ API en l√≠nea")
                    st.json(health_data)
                else:
                    st.error("‚ùå API no disponible")
        
        if st.button("Estado Detallado"):
            status_data = make_api_request("/status")
            if status_data:
                st.json(status_data)
        
        if st.button("Limpiar Cache"):
            result = make_api_request("/cache/clear", method="DELETE")
            if result:
                st.success(result.get("message", "Cache limpiado"))
    
    # Tabs principales
    tab1, tab2, tab3 = st.tabs(["üéØ An√°lisis de Portafolio", "üìä An√°lisis de Stocks", "üìã Informaci√≥n"])
    
    with tab1:
        st.header("Optimizaci√≥n de Portafolio con Sentiment Analysis")
        
        # Formulario de configuraci√≥n
        with st.form("portfolio_form"):
            col1, col2 = st.columns(2)
            
            with col1:
                sentiment_url = st.text_input(
                    "URL de datos de sentiment",
                    value="https://raw.githubusercontent.com/SalomeAc/Infraestructuras-proyecto/refs/heads/main/sentiment_data.csv"
                )
                start_date = st.date_input("Fecha inicio", value=date(2021, 1, 1))
                top_n_stocks = st.slider("Top N stocks por mes", 3, 10, 5)
            
            with col2:
                end_date = st.date_input("Fecha fin", value=date(2023, 3, 1))
                benchmark_ticker = st.selectbox("Benchmark", ["QQQ", "SPY", "IWM"], index=0)
            
            submitted = st.form_submit_button("üöÄ Ejecutar An√°lisis", type="primary")
        
        if submitted:
            # Preparar datos de la petici√≥n
            request_data = {
                "sentiment_url": sentiment_url,
                "start_date": start_date.strftime("%Y-%m-%d"),
                "end_date": end_date.strftime("%Y-%m-%d"),
                "top_n_stocks": top_n_stocks,
                "benchmark_ticker": benchmark_ticker
            }
            
            # Mostrar progress bar
            progress_bar = st.progress(0)
            status_text = st.empty()
            
            status_text.text("Enviando petici√≥n a la API...")
            progress_bar.progress(10)
            
            # Realizar petici√≥n
            with st.spinner("Procesando an√°lisis (esto puede tomar varios minutos)..."):
                start_time = time.time()
                result = make_api_request("/portfolio/analyze", method="POST", data=request_data)
                end_time = time.time()
                
                progress_bar.progress(100)
                status_text.text(f"Completado en {end_time - start_time:.2f} segundos")
            
            if result and result.get("status") == "success":
                st.success("‚úÖ An√°lisis completado exitosamente!")
                
                # Mostrar m√©tricas principales
                analysis = result["analysis"]
                
                col1, col2, col3, col4 = st.columns(4)
                with col1:
                    st.metric(
                        "Retorno Total Portafolio",
                        f"{analysis['total_portfolio_return']:.2%}",
                        delta=f"{analysis['excess_return']:.2%}"
                    )
                with col2:
                    st.metric(
                        "Retorno Benchmark",
                        f"{analysis['total_benchmark_return']:.2%}"
                    )
                with col3:
                    st.metric(
                        "Volatilidad Portafolio",
                        f"{analysis['portfolio_volatility']:.2%}"
                    )
                with col4:
                    st.metric(
                        "Sharpe Ratio",
                        f"{analysis['sharpe_ratio']:.3f}"
                    )
                
                # Gr√°fico de performance
                st.subheader("üìà Performance Comparativa")
                fig = plot_performance_comparison(result["performance_data"])
                st.plotly_chart(fig, use_container_width=True)
                
                # Composici√≥n del portafolio
                st.subheader("üìã Composici√≥n del Portafolio")
                show_portfolio_composition(result["portfolio_composition"])
                
                # Detalles t√©cnicos
                with st.expander("üîç Detalles T√©cnicos"):
                    st.json(result["metadata"])
            
            elif result:
                st.error(f"‚ùå Error en el an√°lisis: {result}")
    
    with tab2:
        st.header("An√°lisis Individual de Stocks")
        
        with st.form("stocks_form"):
            symbols_input = st.text_area(
                "S√≠mbolos de stocks (separados por comas)",
                value="AAPL, MSFT, GOOGL, AMZN, TSLA",
                help="Ingrese los s√≠mbolos separados por comas"
            )
            
            col1, col2 = st.columns(2)
            with col1:
                stock_start_date = st.date_input("Fecha inicio", value=date(2021, 1, 1), key="stock_start")
            with col2:
                stock_end_date = st.date_input("Fecha fin", value=date(2023, 3, 1), key="stock_end")
            
            analyze_stocks = st.form_submit_button("üìä Analizar Stocks")
        
        if analyze_stocks:
            symbols = [s.strip().upper() for s in symbols_input.split(",") if s.strip()]
            
            if symbols:
                request_data = {
                    "symbols": symbols,
                    "start_date": stock_start_date.strftime("%Y-%m-%d"),
                    "end_date": stock_end_date.strftime("%Y-%m-%d")
                }
                
                with st.spinner("Analizando stocks..."):
                    result = make_api_request("/stocks/analyze", method="POST", data=request_data)
                
                if result and result.get("status") == "success":
                    st.success(f"‚úÖ An√°lisis completado para {result['stocks_analyzed']} stocks")
                    
                    # Crear DataFrame con m√©tricas
                    metrics_data = []
                    for symbol, metrics in result["metrics"].items():
                        metrics_data.append({
                            "Stock": symbol,
                            "Retorno Total": f"{metrics['total_return']:.2%}",
                            "Volatilidad": f"{metrics['volatility']:.2%}",
                            "Sharpe Ratio": f"{metrics['sharpe_ratio']:.3f}",
                            "Datos": metrics['data_points']
                        })
                    
                    df = pd.DataFrame(metrics_data)
                    st.dataframe(df, use_container_width=True)
                    
                    # Gr√°fico de retorno vs volatilidad
                    if len(result["metrics"]) > 1:
                        fig = px.scatter(
                            x=[m['volatility'] for m in result["metrics"].values()],
                            y=[m['total_return'] for m in result["metrics"].values()],
                            text=list(result["metrics"].keys()),
                            labels={"x": "Volatilidad", "y": "Retorno Total"},
                            title="Retorno vs Volatilidad"
                        )
                        fig.update_traces(textposition="top center")
                        st.plotly_chart(fig, use_container_width=True)
                
                else:
                    st.error("‚ùå Error en el an√°lisis de stocks")
            else:
                st.warning("‚ö†Ô∏è Por favor ingrese al menos un s√≠mbolo de stock")
    
    with tab3:
        st.header("üìã Informaci√≥n del Sistema")
        
        st.markdown("""
        ### üéØ Caracter√≠sticas de la Aplicaci√≥n
        
        Esta aplicaci√≥n implementa un sistema de optimizaci√≥n de portafolios que utiliza:
        
        - **üîÑ Ray**: Para paralelizaci√≥n de c√°lculos intensivos
        - **üöÄ FastAPI**: API REST de alto rendimiento  
        - **üìä Streamlit**: Interfaz web interactiva
        - **üê≥ Docker**: Containerizaci√≥n para despliegue
        - **‚òÅÔ∏è AWS EC2**: Infraestructura en la nube
        
        ### ‚ö° Optimizaciones de Performance
        
        1. **Descarga paralela de datos**: Los datos de stocks se descargan en lotes paralelos
        2. **Procesamiento distribuido**: Los c√°lculos se distribuyen usando Ray
        3. **Cache inteligente**: Resultados cached para evitar rec√°lculos
        4. **Ray Serve**: Deployment escalable de la API
        
        ### üîß Endpoints de la API
        
        - `GET /`: Informaci√≥n general
        - `GET /health`: Health check
        - `GET /status`: Estado detallado del sistema
        - `POST /portfolio/analyze`: An√°lisis de portafolio
        - `POST /stocks/analyze`: An√°lisis de stocks individuales
        - `DELETE /cache/clear`: Limpiar cache
        """)
        
        # Informaci√≥n de conexi√≥n
        st.subheader("üîó Informaci√≥n de Conexi√≥n")
        st.code(f"API Base URL: {API_BASE_URL}")
        
        # Test de conectividad
        if st.button("üß™ Test de Conectividad"):
            with st.spinner("Probando conexi√≥n..."):
                root_data = make_api_request("/")
                if root_data:
                    st.success("‚úÖ Conexi√≥n exitosa")
                    st.json(root_data)
                else:
                    st.error("‚ùå Error de conexi√≥n")

if __name__ == "__main__":
    main()
